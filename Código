#Importamos HTML para convertir la animación en un vídeo que se pueda guardar
from IPython.display import HTML
import scipy as sci
import numpy as num
import matplotlib
import matplotlib.pyplot as plt
from matplotlib import animation
from mpl_toolkits.mplot3d import Axes3D
#----------------------------------------------------------------------------------------------
G=6.67408e-11 #N-m2/kg2

m_ref=1.989e+30 #kg
r_ref=1.49e+11 #m
v_ref=30000 #m/s
t_ref=365*24*3600*0.016 #s

#Constantes Netas

K1=G*t_ref*m_ref/(r_ref**2*v_ref)
K2=v_ref*t_ref/r_ref
print(K1,K2)

#Masas en unidades solares
m1=1.0 #Sol
m2=3.0e-6 #Tierra
m3=318*m2 #Jupiter

#----------------------------------------------------------------------------------------------
#Posiciones iniciales

r1=[0,-0.6,0] #m
r2=[0,0.4,0] #m
r3=[0,4.6,0] #m

#Convertimos posiciones en arreglos

r1=num.array(r1,dtype="float64")
r2=num.array(r2,dtype="float64")
r3=num.array(r3,dtype="float64")

#Centro de masas

r_cm=(m1*r1+m2*r2+m3*r3)/(m1+m2+m3)

#-----------------------------------------------------------------------------------------------

#Velocidades iniciales

v1=[0,0,0] #m/s
v2=[-0.5,0.1,0] #m/s
v3=[0.22,-0.044,0] #m/s

#Velocidad en arreglos

v1=num.array(v1,dtype="float64")
v2=num.array(v2,dtype="float64")
v3=num.array(v3,dtype="float64")

#Velocidad CM

v_cm=(m1*v1+m2*v2+m3*v3)/(m1+m2+m3)

#---------------------------------------------------------------------------------------------------

def EcuacionesTierra(a,t,G,m1,m2):
    #Establece las posiciones de las variables en el arreglo "a"
    r1=a[:3]
    r2=a[3:6]
    r3=a[6:9]
    v1=a[9:12]
    v2=a[12:15]
    v3=a[15:18]
    
    #Distancias entre posiciones r_i
    r12=sci.linalg.norm(r2-r1)
    r13=sci.linalg.norm(r3-r1)
    r23=sci.linalg.norm(r3-r2)
    
    #Ecuaciones de movimiento
    dv1dt=K1*m2*(r2-r1)/r12**3+K1*m3*(r3-r1)/r13**3
    dv2dt=K1*m1*(r1-r2)/r12**3+K1*m3*(r3-r2)/r23**3
    dv3dt=K1*m1*(r1-r3)/r13**3+K1*m2*(r2-r3)/r23**3
    dr1dt=K2*v1
    dr2dt=K2*v2
    dr3dt=K2*v3
    
    #Introducimos las derivadas en el arreglo final de 18 entradas
    r12_dv=num.concatenate((dr1dt,dr2dt))
    r_dv=num.concatenate((r12_dv,dr3dt))
    v12_dv=num.concatenate((dv1dt,dv2dt))
    v_dv=num.concatenate((v12_dv,dv3dt))
    dv=num.concatenate((r_dv,v_dv))
    return dv

#-------------------------------------------------------------------------------------------

#Parámetros iniciales en el arreglo
prms_ini=num.array([r1,r2,r3,v1,v2,v3]) #Introduce los parámetros iniciales en el arreglo de 18 entradas
prms_ini=prms_ini.flatten() #Convertimos el arreglo en una dimensión
int_t=num.linspace(0,80,1000) #Intervalo de tiempo de solución de la ecuación

#Importamos la solución de la ecuación
import scipy.integrate
sol_EcuacionesTierra=sci.integrate.odeint(EcuacionesTierra,prms_ini,int_t,args=(G,m1,m2))

#--------------------------------------------------------------------------------------------
sol_r10=sol_EcuacionesTierra[:,:3]
sol_r2=sol_EcuacionesTierra[:,3:6]
sol_r30=sol_EcuacionesTierra[:,6:9]

sol_rcm=(m1*sol_r10+m2*sol_r2+m3*sol_r30)/(m1+m2+m3)

sol_r1cm=sol_r10-sol_rcm
sol_r2cm=sol_r2-sol_rcm
sol_r3cm=sol_r30-sol_rcm

#-------------------------------------------------------------------------------------------------
#--------------------------------------------------------------------------------------------------
#MERCURIO

#Masas en unidades solares
m4=1.657e-7 #Mercurio


#----------------------------------------------------------------------------------------------
#Posiciones iniciales
r4=[0,-0.21,0] #m


#Convertimos posiciones en arreglos
r4=num.array(r4,dtype="float64")

#Centro de masas

r_cm2=(m1*r1+m4*r4+m3*r3)/(m1+m4+m3)

#-----------------------------------------------------------------------------------------------

#Velocidades iniciales
v4=[-0.75,0.15,0] #m/s

#Velocidad en arreglos

v4=num.array(v4,dtype="float64")

#Velocidad CM

v_cm2=(m1*v1+m4*v4+m3*v3)/(m1+m4+m3)

#---------------------------------------------------------------------------------------------------

def EcuacionesMercurio(a,t,G,m1,m4):
    #Establece las posiciones de las variables en el arreglo "a"
    r1=a[:3]
    r4=a[3:6]
    r3=a[6:9]
    v1=a[9:12]
    v4=a[12:15]
    v3=a[15:18]
    
    #Distancias entre posiciones r_i
    r14=sci.linalg.norm(r4-r1)
    r13=sci.linalg.norm(r3-r1)
    r43=sci.linalg.norm(r3-r4)
    
    #Ecuaciones de movimiento
    dv1dt=K1*m4*(r4-r1)/r14**3+K1*m3*(r3-r1)/r13**3
    dv4dt=K1*m1*(r1-r4)/r14**3+K1*m3*(r3-r4)/r43**3
    dv3dt=K1*m1*(r1-r3)/r13**3+K1*m4*(r4-r3)/r43**3
    dr1dt=K2*v1
    dr4dt=K2*v4
    dr3dt=K2*v3
    
    #Introducimos las derivadas en el arreglo final de 18 entradas
    r14_dv=num.concatenate((dr1dt,dr4dt))
    r_dv=num.concatenate((r14_dv,dr3dt))
    v14_dv=num.concatenate((dv1dt,dv4dt))
    v_dv=num.concatenate((v14_dv,dv3dt))
    dv=num.concatenate((r_dv,v_dv))
    return dv

#-------------------------------------------------------------------------------------------

#Parámetros iniciales en el arreglo
prms_ini2=num.array([r1,r4,r3,v1,v4,v3]) #Introduce los parámetros iniciales en el arreglo de 18 entradas
prms_ini2=prms_ini2.flatten() #Convertimos el arreglo en una dimensión
int_t2=num.linspace(0,80,1000) #Intervalo de tiempo de solución de la ecuación

#Importamos la solución de la ecuación
import scipy.integrate
sol_EcuacionesMercurio=sci.integrate.odeint(EcuacionesMercurio,prms_ini2,int_t2,args=(G,m1,m4))

#--------------------------------------------------------------------------------------------
sol_r11=sol_EcuacionesMercurio[:,:3]
sol_r4=sol_EcuacionesMercurio[:,3:6]
sol_r31=sol_EcuacionesMercurio[:,6:9]

sol_rcm2=(m1*sol_r11+m4*sol_r4+m3*sol_r31)/(m1+m4+m3)

sol_r4cm=sol_r4-sol_rcm2

#------------------------------------------------------------------------------------------------------------
#------------------------------------------------------------------------------------------------------------
#------------------------------------------------------------------------------------------------------------
#Venus

#Masas en unidades solares
m5=3.0e-6 #Venus


#----------------------------------------------------------------------------------------------
#Posiciones iniciales
r5=[0,0.12,0] #m


#Convertimos posiciones en arreglos
r5=num.array(r5,dtype="float64")

#Centro de masas

r_cm3=(m1*r1+m5*r5+m3*r3)/(m1+m5+m3)

#-----------------------------------------------------------------------------------------------

#Velocidades iniciales
v5=[-0.6,0.12,0] #m/s

#Velocidad en arreglos

v5=num.array(v5,dtype="float64")

#Velocidad CM

v_cm3=(m1*v1+m5*v5+m3*v3)/(m1+m5+m3)

#---------------------------------------------------------------------------------------------------

def EcuacionesVenus(a,t,G,m1,m5):
    #Establece las posiciones de las variables en el arreglo "a"
    r1=a[:3]
    r5=a[3:6]
    r3=a[6:9]
    v1=a[9:12]
    v5=a[12:15]
    v3=a[15:18]
    
    #Distancias entre posiciones r_i
    r15=sci.linalg.norm(r5-r1)
    r13=sci.linalg.norm(r3-r1)
    r53=sci.linalg.norm(r3-r5)
    
    #Ecuaciones de movimiento
    dv1dt=K1*m5*(r5-r1)/r15**3+K1*m3*(r3-r1)/r13**3
    dv5dt=K1*m1*(r1-r5)/r15**3+K1*m3*(r3-r5)/r53**3
    dv3dt=K1*m1*(r1-r3)/r13**3+K1*m5*(r5-r3)/r53**3
    dr1dt=K2*v1
    dr5dt=K2*v5
    dr3dt=K2*v3
    
    #Introducimos las derivadas en el arreglo final de 18 entradas
    r15_dv=num.concatenate((dr1dt,dr5dt))
    r_dv=num.concatenate((r15_dv,dr3dt))
    v15_dv=num.concatenate((dv1dt,dv5dt))
    v_dv=num.concatenate((v15_dv,dv3dt))
    dv=num.concatenate((r_dv,v_dv))
    return dv

#-------------------------------------------------------------------------------------------

#Parámetros iniciales en el arreglo
prms_ini3=num.array([r1,r5,r3,v1,v5,v3]) #Introduce los parámetros iniciales en el arreglo de 18 entradas
prms_ini3=prms_ini3.flatten() #Convertimos el arreglo en una dimensión
int_t3=num.linspace(0,80,1000) #Intervalo de tiempo de solución de la ecuación

#Importamos la solución de la ecuación
import scipy.integrate
sol_EcuacionesVenus=sci.integrate.odeint(EcuacionesVenus,prms_ini3,int_t3,args=(G,m1,m5))

#--------------------------------------------------------------------------------------------
sol_r12=sol_EcuacionesVenus[:,:3]
sol_r5=sol_EcuacionesVenus[:,3:6]
sol_r32=sol_EcuacionesVenus[:,6:9]

sol_rcm3=(m1*sol_r12+m5*sol_r5+m3*sol_r32)/(m1+m5+m3)

sol_r5cm=sol_r5-sol_rcm3

#---------------------------------------------------------------------------------------------------
#--------------------------------------------------------------------------------------------------
#------------------------------------------------------------------------------------------------------

#Marte

#Masas en unidades solares
m6=3.213e-7 #Marte


#----------------------------------------------------------------------------------------------
#Posiciones iniciales
r6=[0,0.92,0] #m


#Convertimos posiciones en arreglos
r6=num.array(r6,dtype="float64")

#Centro de masas

r_cm4=(m1*r1+m6*r6+m3*r3)/(m1+m6+m3)

#-----------------------------------------------------------------------------------------------

#Velocidades iniciales
v6=[-0.4,0.08,0] #m/s

#Velocidad en arreglos

v6=num.array(v6,dtype="float64")

#Velocidad CM

v_cm4=(m1*v1+m6*v6+m3*v3)/(m1+m6+m3)

#---------------------------------------------------------------------------------------------------

def EcuacionesMarte(a,t,G,m1,m6):
    #Establece las posiciones de las variables en el arreglo "a"
    r1=a[:3]
    r6=a[3:6]
    r3=a[6:9]
    v1=a[9:12]
    v6=a[12:15]
    v3=a[15:18]
    
    #Distancias entre posiciones r_i
    r16=sci.linalg.norm(r6-r1)
    r13=sci.linalg.norm(r3-r1)
    r63=sci.linalg.norm(r3-r6)
    
    #Ecuaciones de movimiento
    dv1dt=K1*m6*(r6-r1)/r16**3+K1*m3*(r3-r1)/r13**3
    dv6dt=K1*m1*(r1-r6)/r16**3+K1*m3*(r3-r6)/r63**3
    dv3dt=K1*m1*(r1-r3)/r13**3+K1*m6*(r6-r3)/r63**3
    dr1dt=K2*v1
    dr6dt=K2*v6
    dr3dt=K2*v3
    
    #Introducimos las derivadas en el arreglo final de 18 entradas
    r16_dv=num.concatenate((dr1dt,dr6dt))
    r_dv=num.concatenate((r16_dv,dr3dt))
    v16_dv=num.concatenate((dv1dt,dv6dt))
    v_dv=num.concatenate((v16_dv,dv3dt))
    dv=num.concatenate((r_dv,v_dv))
    return dv

#-------------------------------------------------------------------------------------------

#Parámetros iniciales en el arreglo
prms_ini4=num.array([r1,r6,r3,v1,v6,v3]) #Introduce los parámetros iniciales en el arreglo de 18 entradas
prms_ini4=prms_ini4.flatten() #Convertimos el arreglo en una dimensión
int_t4=num.linspace(0,80,1000) #Intervalo de tiempo de solución de la ecuación

#Importamos la solución de la ecuación
import scipy.integrate
sol_EcuacionesMarte=sci.integrate.odeint(EcuacionesMarte,prms_ini4,int_t4,args=(G,m1,m6))

#--------------------------------------------------------------------------------------------
sol_r13=sol_EcuacionesMarte[:,:3]
sol_r6=sol_EcuacionesMarte[:,3:6]
sol_r33=sol_EcuacionesMarte[:,6:9]

sol_rcm4=(m1*sol_r13+m6*sol_r6+m3*sol_r33)/(m1+m6+m3)

sol_r6cm=sol_r6-sol_rcm4

#-----------------------------------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------
#------------------------------------------------------------------------------------------------------------
#PLOT Y ANIMACION

fig=plt.figure(figsize=(15,15))
ax=fig.add_subplot(111,projection="3d")
ax.plot(sol_r1cm[:,0],sol_r1cm[:,1]+0.4,sol_r1cm[:,2],color="orangered")
ax.plot(sol_r2cm[:,0],sol_r2cm[:,1],sol_r2cm[:,2],color="darkblue")
ax.plot(sol_r4cm[:,0],sol_r4cm[:,1]+0.2,sol_r4cm[:,2],color="gray")
ax.plot(sol_r5cm[:,0],sol_r5cm[:,1]+0.1,sol_r5cm[:,2],color="green")
ax.plot(sol_r6cm[:,0],sol_r6cm[:,1]-0.25,sol_r6cm[:,2],color="darkred")
ax.plot(sol_r3cm[:,0],sol_r3cm[:,1],sol_r3cm[:,2],color="tan")
ax.scatter(sol_r1cm[-1,0],sol_r1cm[-1,1]+0.4,sol_r1cm[-1,2],color="orange",marker="o",s=1000,label="Sol")
ax.scatter(sol_r2cm[-1,0],sol_r2cm[-1,1],sol_r2cm[-1,2],color="darkblue",marker="o",s=150,label="Tierra")
ax.scatter(sol_r4cm[-1,0],sol_r4cm[-1,1]+0.2,sol_r4cm[-1,2],color="gray",marker="o",s=60,label="Mercurio")
ax.scatter(sol_r5cm[-1,0],sol_r5cm[-1,1]+0.1,sol_r5cm[-1,2],color="green",marker="o",s=100,label="Venus")
ax.scatter(sol_r6cm[-1,0],sol_r6cm[-1,1]-0.25,sol_r6cm[-1,2],color="darkred",marker="o",s=80,label="Marte")
ax.scatter(sol_r3cm[-1,0],sol_r3cm[-1,1],sol_r3cm[-1,2],color="tan",marker="o",s=400,label="Jupiter")
ax.set_xlabel("coordenada-x",fontsize=14)
ax.set_ylabel("coordenada-y",fontsize=14)
ax.set_zlabel("coordenada-z",fontsize=14)
ax.set_title("Problema de tres cuerpos Tierra-Jupiter-Sol\n",fontsize=14)
ax.legend(loc="upper left",fontsize=14)

#--------------------------------------------------------------------------------------------
#Animacion

#Creamos la grafica 
fig=plt.figure(figsize=(20,20))
ax=fig.add_subplot(111,projection="3d")

#Creamos nuevos arreglos para la animacion, lo que nos da
#la flexibilidad para reducir el numero de puntos en la
#animación para que en caso de que se ponga lenta, seleccione cada cuarto punto

anim_sol_r1=sol_r1cm[::4,:].copy()
anim_sol_r2=sol_r2cm[::4,:].copy()
anim_sol_r4=sol_r4cm[::4,:].copy()
anim_sol_r5=sol_r5cm[::4,:].copy()
anim_sol_r6=sol_r6cm[::4,:].copy()
anim_sol_r3=sol_r3cm[::4,:].copy()

#Establecemos la grafica inicial para los planetas en sus posiciones iniciales
traza1=[ax.scatter(anim_sol_r1[0,0],anim_sol_r1[0,1]+0.4,anim_sol_r1[0,2],color="orangered",marker="o",s=1000)]
traza2=[ax.scatter(anim_sol_r2[0,0],anim_sol_r2[0,1],anim_sol_r2[0,2],color="darkblue",marker="o",s=150)]
traza4=[ax.scatter(anim_sol_r4[0,0],anim_sol_r4[0,1],anim_sol_r4[0,2],color="gray",marker="o",s=60)]
traza5=[ax.scatter(anim_sol_r5[0,0],anim_sol_r5[0,1],anim_sol_r5[0,2],color="green",marker="o",s=100)]
traza6=[ax.scatter(anim_sol_r6[0,0],anim_sol_r6[0,1],anim_sol_r6[0,2],color="darkred",marker="o",s=80)]
traza3=[ax.scatter(anim_sol_r3[0,0],anim_sol_r3[0,1],anim_sol_r3[0,2],color="tan",marker="o",s=400)]
#Creamos la función Animacion que cambia la grafica cada frame i
def Animar(i,traza1,traza2,traza3,traza4,traza5,traza6):
    #Removemos 
    traza1[0].remove()
    traza2[0].remove()
    traza4[0].remove()
    traza5[0].remove()
    traza6[0].remove()
    traza3[0].remove()
    
    
    #Graficamos las orbitas desde la posición inicial a la actual
    orbita1=ax.plot(anim_sol_r1[:i,0],anim_sol_r1[:i,1]+0.4,anim_sol_r1[:i,2],color="orangered")
    orbita2=ax.plot(anim_sol_r2[:i,0],anim_sol_r2[:i,1],anim_sol_r2[:i,2],color="darkblue")
    orbita4=ax.plot(anim_sol_r4[:i,0],anim_sol_r4[:i,1]+0.2,anim_sol_r4[:i,2],color="gray")
    orbita5=ax.plot(anim_sol_r5[:i,0],anim_sol_r5[:i,1]+0.1,anim_sol_r5[:i,2],color="green")
    orbita6=ax.plot(anim_sol_r6[:i,0],anim_sol_r6[:i,1]-0.25,anim_sol_r6[:i,2],color="darkred")
    orbita3=ax.plot(anim_sol_r3[:i,0],anim_sol_r3[:i,1],anim_sol_r3[:i,2],color="tan")
    
    #Grafica los planetitas
    traza1[0]=ax.scatter(anim_sol_r1[i-1,0],anim_sol_r1[i-1,1]+0.4,anim_sol_r1[i-1,2],color="orangered",marker="o",s=1000)
    traza2[0]=ax.scatter(anim_sol_r2[i-1,0],anim_sol_r2[i-1,1],anim_sol_r2[i-1,2],color="darkblue",marker="o",s=150)
    traza4[0]=ax.scatter(anim_sol_r4[i-1,0],anim_sol_r4[i-1,1]+0.2,anim_sol_r4[i-1,2],color="gray",marker="o",s=60)
    traza5[0]=ax.scatter(anim_sol_r5[i-1,0],anim_sol_r5[i-1,1]+0.1,anim_sol_r5[i-1,2],color="green",marker="o",s=100)
    traza6[0]=ax.scatter(anim_sol_r6[i-1,0],anim_sol_r6[i-1,1]-0.25,anim_sol_r6[i-1,2],color="darkred",marker="o",s=80)
    traza3[0]=ax.scatter(anim_sol_r3[i-1,0],anim_sol_r3[i-1,1],anim_sol_r3[i-1,2],color="tan",marker="o",s=400)
    return orbita1,orbita2,orbita3,orbita4,orbita5,orbita6,traza1,traza2,traza3,traza4,traza5,traza6

#Marcacion ejes
fig.set_facecolor('black')
ax.set_facecolor('black')
ax.grid(False)
ax.w_xaxis.pane.fill = False
ax.w_yaxis.pane.fill = False
ax.w_zaxis.pane.fill = False
#ax.w_xaxis.set_pane_color((0.0, 0.0, 0.0, 0.0))
#ax.w_yaxis.set_pane_color((0.0, 0.0, 0.0, 0.0))
#ax.w_zaxis.set_pane_color((0.0, 0.0, 0.0, 0.0))
ax.set_xlabel("coordenada-x",fontsize=14)
ax.set_ylabel("coodenada-y",fontsize=14)
ax.set_zlabel("coordenada-z",fontsize=14)
ax.set_title("Problema de tres cuerpos Tierra-Jupiter-Sol\n",fontsize=14)

#Usamos la funcion FuncAnimation para realizar la animacion
anim=animation.FuncAnimation(fig,Animar,frames=250,interval=40,repeat=False,blit=False,fargs=(traza1,traza2,traza3,traza4,traza5,traza6))

matplotlib.rcParams['animation.embed_limit'] = 4**128 #Increase animation embed limit
HTML(anim.to_jshtml()) #Convertimos la animacion a jsanimation para que nos muestre los botones y la animacion

#Podemos usar este comando para guardar un video de la animacion

#anim.save("Problema3C.mp4")
